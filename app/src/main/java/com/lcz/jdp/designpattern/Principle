# 1. 开闭原则 (OCP - Open Closed Principle) - 对扩展开放，对修改关闭
1. 含义:当应用的需求改变时，在不修改源代码的前提下，可以扩展模块的功能，以满足新的需求
2. 作用:
    1. 软件测试时，只需对扩展的部分进行测试
    2. 提高代码的复用性，粒度越小，被复用的可能性就越大
    3. 提高软件的可维护性
3. 实现方法:
    1. 通过 "抽象约束，封装变化" 来实现
    2. 抽象约束:通过接口或者抽象类为软件实体定义一个相对稳定的抽象层
    3. 封装变化:将相同的可变因素封装在相同的具体实现类中 

# 2. 里氏替换原则 (LSP - Liskov Substitution Principle) - 子类可以扩展父类原有功能，但不能改变父类原有的功能(尽量不要重写父类的方法)
1. 作用: 
    1. 是实现 OCP 的重要方式之一 
    2. 克服了继承中重写父类造成的可复用性变差的缺点
    3. 是动作正确性的保证.类的扩展不会给已有的系统引入新的错误

# 3. 依赖倒置原则 (DIP - Dependence Inversion Principle) - 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象
1. 核心思想:要面向接口编程，而不是面向实现编程
2. 作用:
    1. 是实现 OCP 的重要途径之一，降低了客户与实现模块之间的耦合度
    2. 提高系统稳定性，代码的可读性和可维护性
3. 实现方法:
    1. 每个类尽量提供接口或抽象类
    2. 变量的声明类型尽量是接口或者抽象类
    3. 任何类都不应该从具体类派生
    4. 使用继承时尽量遵循 LSP
    
# 4. 单一职责原则 (SRP - Single Responsibility Principle) - 一个类有且仅有一个引起它拜年话的原因，否则类就该被拆分
1. 含义:对象不应该存在太多职责，会削弱或抑制该类实现其他职责的能力，冗余代码
2. 核心:控制类的粒度大小，将对象解耦
3. 优点:
    1. 降低类的复杂度，提高可读性，可维护性
    2. 变更会显著降低对其他功能的影响
4. 实现方法:类的职责分离

# 5. 接口隔离原则 (ISP - Interface Segregation Principle) - 一个类对另一个类的依赖应该建立在最小的接口上(只包含客户感兴趣的方法)
1. 含义:
    1. 为各个类建立专用接口，而不是庞大的接口共所有依赖它的类去调用 
    2. SRP 注重的是职责，ISP 注重对接口依赖的隔离
    3. SRP 主要是约束类，针对程序的实现和细节；ISP 主要约束接口，针对抽象和程序整体框架的构建
2. 优点:
    1. 将臃肿的接口分解为多个粒度小的接口，可预防外来变更的扩散，提高系统的灵活性和可维护性
    2. 提高系统的内聚性，减少对外交互，降低系统的耦合性
    3. 减少冗余代码
 3. 实现方法:
    1. 接口尽量小，但要有限度，一个接口只服务于一个子模块或业务逻辑
    2. 为依赖接口的类提供定制服务，只提供调用者需要的方法
    
# 6. 迪米特法则 (LOD - Law of Demeter) - 又名，最少知识原则 (LKP - Least Knowledge Principle)
1. 含义:两个软件实体无需直接通信，那么不应该发生直接的相互调用，可以通过第三方转发该调用
2. 优点:
    1. 限制软件实体之间通信的宽度和深度
    2. 降低耦合度，提高模块的相对独立性
    3. 要确保高内聚，低耦合的同时，保证系统的结构清晰
3. 强调:
    1. 从依赖者的角度来说，只依赖应该依赖的对象
    2. 从被依赖者来说，只暴露应该暴露的方法
4. 实现方法:
    1. 创建弱耦合的类，有利于实现可复用的目标
    2. 在类的结构设计上，尽量降低类成员的访问权限
    3. 在类的设计上，优先考虑将一个类设置成不变类
    4. 对其他类的引用上，将引用其他对象的次数降到最低
    5. 不暴露类的属性成员，而因该提供相应的访问器(set/get 方法)
    
# 7. 合成复用原则 (CRP - Composite Reuse Principle) - 软件复用时，要尽量先使用组合或者聚合关系来实现，其次才考虑继承
1. 类的复用分为:继承复用和合成复用
    1. 继承复用:
        1. 破坏了类的封装性，继承会将父类的细节暴露给子类，该复用又称 "白箱" 复用
        2. 子类与父类的耦合度高，不利于类的扩展和维护
        3. 限制了复用的灵活性，从父类继承而来的实现是静态的，在编译时已经定义，运行时不能发生改变
    2. 合成复用:
        1. 维护了类的封装性，成分对象的内部细节对新对象是不可见，"黑箱" 复用
        2. 新旧类之间耦合度低，该复用所需依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口
        3. 灵活性高，可以在运行时动态进行
2. 实现方法:
    1. 将已有对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能
    
    
    
# Java 23 种设计模式，分为三大类：
1. 创建型模式(Creation Type 5种)：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式
2. 结构型模式(Structure Type 7种)：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式
3. 行为型模式(Behavior Type 11种)：策略模式，模板方法模式，观察者模式，迭代子模式，责任链模式，命令莫斯，备忘录模式，状态模式，访问者模式，中介模式，解释器模式
